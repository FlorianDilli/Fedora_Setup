#!/bin/bash

# Path to the colors file generated by Wallust
FILE="/home/florian/.cache/wallust/shell-colors.sh"

# --- Diagnostic: Check if the file exists ---
if [[ ! -f "$FILE" ]]; then
    echo "Error: Color file not found at $FILE" >&2
    exit 1
fi

# Associative array to hold colors
declare -A color_map

# Use a more robust sed pattern to extract key/value pairs
SED_OUTPUT=$(sed -n "
    /^[[:space:]]*#/d             # Ignore comments
    /^[[:space:]]*$/d             # Ignore empty lines
    # Match lines like key='value'
    /^[[:space:]]*[a-zA-Z0-9_]*='[^']*'/ {
        s/^[[:space:]]*\([a-zA-Z0-9_]*\)='\([^']*\)'.*/\1 \2/p
    }
" "$FILE")

# --- Diagnostic: Check what sed produced ---
# Uncomment the next three lines to see the raw output from sed and its character codes
# echo "--- SED Output (raw) ---"
# printf "%s\n" "$SED_OUTPUT"
# echo "--- SED Output (with cat -A to show non-printables) ---"
# printf "%s\n" "$SED_OUTPUT" | cat -A
# echo "------------------"

# Read the extracted key/value pairs from the sed output
while IFS=' ' read -r key value; do
    # --- Value Cleanup ---
    # 1. Remove potential trailing carriage return (from DOS/Windows line endings)
    value="${value%$'\r'}"
    # 2. Trim leading whitespace (spaces/tabs) from value
    value="${value#"${value%%[![:blank:]]*}"}"
    # 3. Trim trailing whitespace (spaces/tabs) from value
    value="${value%"${value##*[![:blank:]]}"}"

    # --- Diagnostic: Show cleaned key and value ---
    # echo "Debug: Cleaned key='$key', Cleaned value='$value'"
    # printf "Value as hex: " ; printf "%s" "$value" | xxd -p ; echo

    case "$key" in
        color[0-9]|color1[0-5])
            index="${key#color}"
            case "$value" in
                '#'[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])
                    color_map["$index"]="$value"
                    ;;
                *)
                    echo "Warning: Invalid color format for $key: '$value' (after cleanup). Will be treated as missing." >&2
                    ;;
            esac
            ;;
        background|foreground|cursor)
            case "$value" in
                '#'[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])
                    color_map["$key"]="$value"
                    ;;
                *)
                    echo "Warning: Invalid color format for $key: '$value' (after cleanup). Will be treated as missing." >&2
                    ;;
            esac
            ;;
        *)
            # Ignore other keys not explicitly handled
            ;;
    esac
done <<< "$SED_OUTPUT"

# --- Diagnostic: Check the populated color_map ---
# Uncomment the next lines to see what ended up in the associative array
# echo "--- color_map contents ---"
# for k in "${!color_map[@]}"; do echo "color_map[\"$k\"] = \"${color_map[$k]}\""; done
# echo "--------------------------"

# --- Validate and Prepare Colors ---
declare -a colors_indexed=() # For color0-15
any_errors=false

# Validate and prepare numeric colors (color0-color15)
for i in {0..15}; do
    if [[ -v color_map["$i"] ]]; then
        colors_indexed[$i]="${color_map[$i]}"
    else
        echo "Error: Color color$i is missing or was invalid in $FILE." >&2
        any_errors=true
        colors_indexed[$i]="#000000" # Placeholder
    fi
done

# Validate special colors (background, foreground, cursor)
special_color_keys=("background" "foreground" "cursor")
for special_key in "${special_color_keys[@]}"; do
    if ! [[ -v color_map["$special_key"] ]]; then
        echo "Error: Special color '$special_key' is missing or was invalid in $FILE." >&2
        any_errors=true
        color_map["$special_key"]="#ERROR00" # Placeholder
    fi
done

# Exit if any colors were missing or invalid
if $any_errors; then
    echo "Aborting due to missing or invalid color definitions." >&2
    exit 1
fi

# --- Display Logic ---
display_color() {
    local name="$1"
    local hex="$2"
    local r g b hex_nohash

    if [[ "$hex" =~ ^#[0-9A-Fa-f]{6}$ ]]; then
        hex_nohash="${hex/#\#/}"
        r=$((16#${hex_nohash:0:2}))
        g=$((16#${hex_nohash:2:2}))
        b=$((16#${hex_nohash:4:2}))

        # Ensure RGB values are not too dark for typical display blocks
        # This specific adjustment might depend on terminal background
        # (( r < 10 )) && r=10 # Example adjustment, might not be needed by user
        # (( g < 10 )) && g=10
        # (( b < 10 )) && b=10

        printf "%-12s: %-10s " "$name" "$hex"
        printf "\033[48;2;%d;%d;%dm    \033[0m\n" "$r" "$g" "$b"
    else
         echo "Error (display_color): Invalid hex color value for $name: '$hex'" >&2
         printf "%-12s: %-10s \n" "$name" "$hex"
    fi
}

echo "--- Numeric Colors (0-15) ---"
for ((i=0; i<${#colors_indexed[@]}; i++)); do
    display_color "Color $i" "${colors_indexed[i]}"
done

echo
echo "--- Special Colors ---"
display_color "Background" "${color_map["background"]}"
display_color "Foreground" "${color_map["foreground"]}"
display_color "Cursor" "${color_map["cursor"]}"

exit 0
